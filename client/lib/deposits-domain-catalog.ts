// Comprehensive Deposits & Funding Domain Catalog
// 300+ metrics across 4 levels of granularity
// Aligned with top-tier banking practices (JPM, BAC, WFC, Citi)

import { type MetricDef } from "./domain-metrics";

// Level 1: Portfolio-Level Metrics (Strategic)
// Level 2: Product-Level Metrics (Tactical)
// Level 3: Segment/Geography-Level Metrics (Operational)
// Level 4: Granular Transaction/Daily Metrics (Detailed)

export type DepositsMetricLevel = "L1-Portfolio" | "L2-Product" | "L3-Segment" | "L4-Granular";
export type DepositsProductType = "DDA" | "Savings" | "MMA" | "CD" | "Sweep" | "Escrow" | "All";

export interface DepositsMetric extends MetricDef {
  level: DepositsMetricLevel;
  productType: DepositsProductType;
  regulatoryRelevance?: string[];
  alcoRelevance: boolean;
  treasuryRelevance: boolean;
}

// ============================================================================
// LEVEL 1: PORTFOLIO-LEVEL STRATEGIC METRICS (~50 metrics)
// ============================================================================

const portfolioMetrics: Omit<DepositsMetric, "id">[] = [
  // Total Balance Metrics
  {
    domain: "Deposits",
    subdomain: "Portfolio Management",
    name: "Total Deposit Balances",
    technical_name: "total_deposit_balances",
    grain: "daily",
    aggregation: "sum",
    data_type: "currency",
    source_silver_table: "silver.account_positions_daily",
    source_silver_column: "eod_balance",
    source_gold_table: "gold.fact_deposit_positions",
    source_gold_column: "balance_amount",
    metric_type: "operational",
    definition: "Total end-of-day deposit balances across all deposit accounts",
    sql: "SELECT as_of_date, SUM(balance_amount) FROM gold.fact_deposit_positions WHERE product_category = 'DEPOSITS' GROUP BY as_of_date;",
    level: "L1-Portfolio",
    productType: "All",
    alcoRelevance: true,
    treasuryRelevance: true,
    regulatoryRelevance: ["LCR", "NSFR", "Basel III"]
  },
  {
    domain: "Deposits",
    subdomain: "Portfolio Management",
    name: "Average Daily Balance (ADB) - Portfolio",
    technical_name: "portfolio_adb",
    grain: "monthly",
    aggregation: "avg",
    data_type: "currency",
    source_silver_table: "silver.account_positions_daily",
    source_silver_column: "eod_balance",
    source_gold_table: "gold.fact_deposit_positions",
    source_gold_column: "balance_amount",
    metric_type: "operational",
    definition: "Average daily balance across entire deposit portfolio for the period",
    sql: "SELECT DATE_TRUNC('month', as_of_date) as month, AVG(daily_total_balance) FROM (SELECT as_of_date, SUM(balance_amount) as daily_total_balance FROM gold.fact_deposit_positions GROUP BY as_of_date) GROUP BY month;",
    level: "L1-Portfolio",
    productType: "All",
    alcoRelevance: true,
    treasuryRelevance: true,
    regulatoryRelevance: ["LCR"]
  },
  {
    domain: "Deposits",
    subdomain: "Portfolio Management",
    name: "Deposit Growth Rate (MoM)",
    technical_name: "deposit_growth_mom",
    grain: "monthly",
    aggregation: "calculated",
    data_type: "percent",
    source_silver_table: "silver.account_positions_daily",
    source_silver_column: "eod_balance",
    source_gold_table: "gold.fact_deposit_positions",
    source_gold_column: "balance_amount",
    metric_type: "analytics",
    definition: "Month-over-month growth rate of total deposit balances",
    sql: "SELECT month, (current_month_balance - prior_month_balance) / prior_month_balance as growth_rate FROM (SELECT DATE_TRUNC('month', as_of_date) as month, SUM(balance_amount) as current_month_balance, LAG(SUM(balance_amount)) OVER (ORDER BY DATE_TRUNC('month', as_of_date)) as prior_month_balance FROM gold.fact_deposit_positions GROUP BY month);",
    level: "L1-Portfolio",
    productType: "All",
    alcoRelevance: true,
    treasuryRelevance: true,
    regulatoryRelevance: []
  },
  {
    domain: "Deposits",
    subdomain: "Portfolio Management",
    name: "Deposit Growth Rate (YoY)",
    technical_name: "deposit_growth_yoy",
    grain: "monthly",
    aggregation: "calculated",
    data_type: "percent",
    source_silver_table: "silver.account_positions_daily",
    source_silver_column: "eod_balance",
    source_gold_table: "gold.fact_deposit_positions",
    source_gold_column: "balance_amount",
    metric_type: "analytics",
    definition: "Year-over-year growth rate of total deposit balances",
    sql: "SELECT month, (current_balance - prior_year_balance) / prior_year_balance as yoy_growth FROM (SELECT DATE_TRUNC('month', as_of_date) as month, SUM(balance_amount) as current_balance, LAG(SUM(balance_amount), 12) OVER (ORDER BY DATE_TRUNC('month', as_of_date)) as prior_year_balance FROM gold.fact_deposit_positions GROUP BY month);",
    level: "L1-Portfolio",
    productType: "All",
    alcoRelevance: true,
    treasuryRelevance: true,
    regulatoryRelevance: []
  },
  {
    domain: "Deposits",
    subdomain: "Funding & Liquidity",
    name: "Cost of Funds (CoF) - Portfolio",
    technical_name: "portfolio_cost_of_funds",
    grain: "monthly",
    aggregation: "weighted_avg",
    data_type: "percent",
    source_silver_table: "silver.interest_accruals",
    source_silver_column: "accrued_interest",
    source_gold_table: "gold.fact_deposit_interest",
    source_gold_column: "interest_expense",
    metric_type: "operational",
    definition: "Total interest expense as a percentage of average deposit balances (annualized)",
    sql: "SELECT month, (SUM(interest_expense) * 12 / SUM(avg_balance)) * 100 as cof_pct FROM gold.fact_deposit_interest WHERE month = DATE_TRUNC('month', as_of_date) GROUP BY month;",
    level: "L1-Portfolio",
    productType: "All",
    alcoRelevance: true,
    treasuryRelevance: true,
    regulatoryRelevance: ["ALCO Reporting"]
  },
  {
    domain: "Deposits",
    subdomain: "Funding & Liquidity",
    name: "Weighted Average Rate Paid",
    technical_name: "weighted_avg_rate_paid",
    grain: "monthly",
    aggregation: "weighted_avg",
    data_type: "percent",
    source_silver_table: "silver.account_positions_daily",
    source_silver_column: "contract_rate",
    source_gold_table: "gold.fact_deposit_positions",
    source_gold_column: "interest_rate",
    metric_type: "operational",
    definition: "Average interest rate paid weighted by account balances",
    sql: "SELECT month, SUM(balance_amount * interest_rate) / SUM(balance_amount) as weighted_rate FROM gold.fact_deposit_positions GROUP BY DATE_TRUNC('month', as_of_date) as month;",
    level: "L1-Portfolio",
    productType: "All",
    alcoRelevance: true,
    treasuryRelevance: true,
    regulatoryRelevance: []
  },
  {
    domain: "Deposits",
    subdomain: "Account Management",
    name: "Total Deposit Accounts",
    technical_name: "total_deposit_accounts",
    grain: "daily",
    aggregation: "count",
    data_type: "integer",
    source_silver_table: "silver.account_master",
    source_silver_column: "account_id",
    source_gold_table: "gold.dim_deposit_account",
    source_gold_column: "account_key",
    metric_type: "operational",
    definition: "Total number of active deposit accounts",
    sql: "SELECT as_of_date, COUNT(DISTINCT account_id) FROM gold.dim_deposit_account WHERE account_status = 'ACTIVE' GROUP BY as_of_date;",
    level: "L1-Portfolio",
    productType: "All",
    alcoRelevance: false,
    treasuryRelevance: false,
    regulatoryRelevance: []
  },
  {
    domain: "Deposits",
    subdomain: "Account Management",
    name: "Net New Accounts",
    technical_name: "net_new_accounts",
    grain: "monthly",
    aggregation: "calculated",
    data_type: "integer",
    source_silver_table: "silver.account_events",
    source_silver_column: "event_type",
    source_gold_table: "gold.fact_account_events",
    source_gold_column: "account_id",
    metric_type: "operational",
    definition: "New accounts opened minus accounts closed during period",
    sql: "SELECT month, SUM(CASE WHEN event_type = 'OPENED' THEN 1 WHEN event_type = 'CLOSED' THEN -1 ELSE 0 END) as net_new FROM gold.fact_account_events WHERE DATE_TRUNC('month', event_date) = month GROUP BY month;",
    level: "L1-Portfolio",
    productType: "All",
    alcoRelevance: false,
    treasuryRelevance: false,
    regulatoryRelevance: []
  },
  {
    domain: "Deposits",
    subdomain: "Account Management",
    name: "Account Opening Rate",
    technical_name: "account_opening_rate",
    grain: "monthly",
    aggregation: "count",
    data_type: "integer",
    source_silver_table: "silver.account_events",
    source_silver_column: "event_type",
    source_gold_table: "gold.fact_account_events",
    source_gold_column: "account_id",
    metric_type: "operational",
    definition: "Number of new deposit accounts opened during period",
    sql: "SELECT DATE_TRUNC('month', event_date) as month, COUNT(*) FROM gold.fact_account_events WHERE event_type = 'OPENED' GROUP BY month;",
    level: "L1-Portfolio",
    productType: "All",
    alcoRelevance: false,
    treasuryRelevance: false,
    regulatoryRelevance: []
  },
  {
    domain: "Deposits",
    subdomain: "Account Management",
    name: "Account Closure Rate",
    technical_name: "account_closure_rate",
    grain: "monthly",
    aggregation: "count",
    data_type: "integer",
    source_silver_table: "silver.account_events",
    source_silver_column: "event_type",
    source_gold_table: "gold.fact_account_events",
    source_gold_column: "account_id",
    metric_type: "operational",
    definition: "Number of deposit accounts closed during period",
    sql: "SELECT DATE_TRUNC('month', event_date) as month, COUNT(*) FROM gold.fact_account_events WHERE event_type = 'CLOSED' GROUP BY month;",
    level: "L1-Portfolio",
    productType: "All",
    alcoRelevance: false,
    treasuryRelevance: false,
    regulatoryRelevance: []
  },
  {
    domain: "Deposits",
    subdomain: "Account Management",
    name: "Average Balance Per Account",
    technical_name: "avg_balance_per_account",
    grain: "monthly",
    aggregation: "avg",
    data_type: "currency",
    source_silver_table: "silver.account_positions_daily",
    source_silver_column: "eod_balance",
    source_gold_table: "gold.fact_deposit_positions",
    source_gold_column: "balance_amount",
    metric_type: "operational",
    definition: "Average deposit balance per account",
    sql: "SELECT month, SUM(balance_amount) / COUNT(DISTINCT account_id) as avg_balance FROM gold.fact_deposit_positions GROUP BY DATE_TRUNC('month', as_of_date) as month;",
    level: "L1-Portfolio",
    productType: "All",
    alcoRelevance: false,
    treasuryRelevance: false,
    regulatoryRelevance: []
  },
  {
    domain: "Deposits",
    subdomain: "Liquidity Management",
    name: "Interest-Bearing Deposits",
    technical_name: "interest_bearing_deposits",
    grain: "daily",
    aggregation: "sum",
    data_type: "currency",
    source_silver_table: "silver.account_positions_daily",
    source_silver_column: "eod_balance",
    source_gold_table: "gold.fact_deposit_positions",
    source_gold_column: "balance_amount",
    metric_type: "operational",
    definition: "Total balances in interest-bearing deposit accounts",
    sql: "SELECT as_of_date, SUM(balance_amount) FROM gold.fact_deposit_positions WHERE interest_bearing_flag = TRUE GROUP BY as_of_date;",
    level: "L1-Portfolio",
    productType: "All",
    alcoRelevance: true,
    treasuryRelevance: true,
    regulatoryRelevance: ["LCR", "NSFR"]
  },
  {
    domain: "Deposits",
    subdomain: "Liquidity Management",
    name: "Non-Interest-Bearing Deposits",
    technical_name: "non_interest_bearing_deposits",
    grain: "daily",
    aggregation: "sum",
    data_type: "currency",
    source_silver_table: "silver.account_positions_daily",
    source_silver_column: "eod_balance",
    source_gold_table: "gold.fact_deposit_positions",
    source_gold_column: "balance_amount",
    metric_type: "operational",
    definition: "Total balances in non-interest-bearing deposit accounts (free deposits)",
    sql: "SELECT as_of_date, SUM(balance_amount) FROM gold.fact_deposit_positions WHERE interest_bearing_flag = FALSE GROUP BY as_of_date;",
    level: "L1-Portfolio",
    productType: "All",
    alcoRelevance: true,
    treasuryRelevance: true,
    regulatoryRelevance: ["LCR", "NSFR"]
  },
  {
    domain: "Deposits",
    subdomain: "Liquidity Management",
    name: "Deposit Mix - Interest Bearing %",
    technical_name: "deposit_mix_interest_bearing_pct",
    grain: "monthly",
    aggregation: "calculated",
    data_type: "percent",
    source_silver_table: "silver.account_positions_daily",
    source_silver_column: "eod_balance",
    source_gold_table: "gold.fact_deposit_positions",
    source_gold_column: "balance_amount",
    metric_type: "analytics",
    definition: "Percentage of total deposits that are interest-bearing",
    sql: "SELECT month, (SUM(CASE WHEN interest_bearing_flag THEN balance_amount ELSE 0 END) / SUM(balance_amount)) * 100 as ib_pct FROM gold.fact_deposit_positions GROUP BY DATE_TRUNC('month', as_of_date) as month;",
    level: "L1-Portfolio",
    productType: "All",
    alcoRelevance: true,
    treasuryRelevance: true,
    regulatoryRelevance: []
  },
  {
    domain: "Deposits",
    subdomain: "Behavioral Analytics",
    name: "Deposit Beta Coefficient",
    technical_name: "deposit_beta",
    grain: "quarterly",
    aggregation: "calculated",
    data_type: "decimal",
    source_silver_table: "silver.rate_sensitivity_analysis",
    source_silver_column: "rate_change",
    source_gold_table: "gold.fact_deposit_beta",
    source_gold_column: "beta_coefficient",
    metric_type: "model_driven",
    definition: "Deposit rate sensitivity to market rate changes (regression coefficient)",
    sql: "SELECT quarter, REGR_SLOPE(deposit_rate_change, market_rate_change) as beta FROM gold.fact_deposit_beta GROUP BY DATE_TRUNC('quarter', as_of_date) as quarter;",
    level: "L1-Portfolio",
    productType: "All",
    alcoRelevance: true,
    treasuryRelevance: true,
    regulatoryRelevance: ["IRRBB", "Interest Rate Risk"]
  },
  {
    domain: "Deposits",
    subdomain: "Behavioral Analytics",
    name: "Deposit Retention Rate",
    technical_name: "deposit_retention_rate",
    grain: "monthly",
    aggregation: "calculated",
    data_type: "percent",
    source_silver_table: "silver.customer_balances",
    source_silver_column: "balance_amount",
    source_gold_table: "gold.fact_customer_retention",
    source_gold_column: "retained_flag",
    metric_type: "analytics",
    definition: "Percentage of deposit balances retained from prior period",
    sql: "SELECT month, (SUM(CASE WHEN retained_flag THEN balance_amount ELSE 0 END) / LAG(SUM(balance_amount)) OVER (ORDER BY month)) * 100 as retention_rate FROM gold.fact_customer_retention GROUP BY month;",
    level: "L1-Portfolio",
    productType: "All",
    alcoRelevance: true,
    treasuryRelevance: false,
    regulatoryRelevance: []
  },
  {
    domain: "Deposits",
    subdomain: "Regulatory Compliance",
    name: "FDIC Insured Deposits",
    technical_name: "fdic_insured_deposits",
    grain: "daily",
    aggregation: "sum",
    data_type: "currency",
    source_silver_table: "silver.account_positions_daily",
    source_silver_column: "fdic_insured_amount",
    source_gold_table: "gold.fact_deposit_positions",
    source_gold_column: "fdic_insured_balance",
    metric_type: "operational",
    definition: "Total FDIC insured deposit balances (capped at $250K per depositor)",
    sql: "SELECT as_of_date, SUM(LEAST(balance_amount, 250000)) as fdic_insured FROM gold.fact_deposit_positions GROUP BY as_of_date;",
    level: "L1-Portfolio",
    productType: "All",
    alcoRelevance: false,
    treasuryRelevance: false,
    regulatoryRelevance: ["FDIC Insurance"]
  },
  {
    domain: "Deposits",
    subdomain: "Regulatory Compliance",
    name: "Uninsured Deposits",
    technical_name: "uninsured_deposits",
    grain: "daily",
    aggregation: "sum",
    data_type: "currency",
    source_silver_table: "silver.account_positions_daily",
    source_silver_column: "eod_balance",
    source_gold_table: "gold.fact_deposit_positions",
    source_gold_column: "balance_amount",
    metric_type: "operational",
    definition: "Total deposit balances exceeding FDIC insurance limits",
    sql: "SELECT as_of_date, SUM(GREATEST(balance_amount - 250000, 0)) as uninsured FROM gold.fact_deposit_positions GROUP BY as_of_date;",
    level: "L1-Portfolio",
    productType: "All",
    alcoRelevance: true,
    treasuryRelevance: true,
    regulatoryRelevance: ["FDIC Insurance", "Liquidity Risk"]
  },
  {
    domain: "Deposits",
    subdomain: "Regulatory Compliance",
    name: "Brokered Deposits",
    technical_name: "brokered_deposits",
    grain: "daily",
    aggregation: "sum",
    data_type: "currency",
    source_silver_table: "silver.account_positions_daily",
    source_silver_column: "eod_balance",
    source_gold_table: "gold.fact_deposit_positions",
    source_gold_column: "balance_amount",
    metric_type: "operational",
    definition: "Total deposits obtained through deposit brokers",
    sql: "SELECT as_of_date, SUM(balance_amount) FROM gold.fact_deposit_positions WHERE brokered_flag = TRUE GROUP BY as_of_date;",
    level: "L1-Portfolio",
    productType: "All",
    alcoRelevance: true,
    treasuryRelevance: true,
    regulatoryRelevance: ["FDIC", "Well-Capitalized Status"]
  },
  {
    domain: "Deposits",
    subdomain: "Liquidity Management",
    name: "Operational Deposits (LCR)",
    technical_name: "operational_deposits_lcr",
    grain: "monthly",
    aggregation: "sum",
    data_type: "currency",
    source_silver_table: "silver.account_positions_daily",
    source_silver_column: "eod_balance",
    source_gold_table: "gold.fact_deposit_positions",
    source_gold_column: "balance_amount",
    metric_type: "operational",
    definition: "Deposits qualifying as operational under LCR rules (stable retail/SME deposits)",
    sql: "SELECT month, SUM(balance_amount) FROM gold.fact_deposit_positions WHERE operational_deposit_flag = TRUE GROUP BY DATE_TRUNC('month', as_of_date) as month;",
    level: "L1-Portfolio",
    productType: "All",
    alcoRelevance: true,
    treasuryRelevance: true,
    regulatoryRelevance: ["LCR", "Basel III"]
  },
  {
    domain: "Deposits",
    subdomain: "Liquidity Management",
    name: "Stable Funding Amount (NSFR)",
    technical_name: "stable_funding_nsfr",
    grain: "monthly",
    aggregation: "sum",
    data_type: "currency",
    source_silver_table: "silver.account_positions_daily",
    source_silver_column: "eod_balance",
    source_gold_table: "gold.fact_deposit_positions",
    source_gold_column: "balance_amount",
    metric_type: "operational",
    definition: "Available Stable Funding from deposits under NSFR framework",
    sql: "SELECT month, SUM(balance_amount * asf_factor) as stable_funding FROM gold.fact_deposit_positions JOIN gold.dim_nsfr_factors USING (product_type) GROUP BY DATE_TRUNC('month', as_of_date) as month;",
    level: "L1-Portfolio",
    productType: "All",
    alcoRelevance: true,
    treasuryRelevance: true,
    regulatoryRelevance: ["NSFR", "Basel III"]
  },
];

// ============================================================================
// LEVEL 2: PRODUCT-LEVEL METRICS (~100 metrics)
// ============================================================================

const productLevelMetrics: Omit<DepositsMetric, "id">[] = [];

const productTypes: DepositsProductType[] = ["DDA", "Savings", "MMA", "CD", "Sweep"];

// Generate product-specific balance metrics
productTypes.forEach(product => {
  productLevelMetrics.push(
    {
      domain: "Deposits",
      subdomain: `${product} Products`,
      name: `${product} Total Balances`,
      technical_name: `${product.toLowerCase()}_total_balances`,
      grain: "daily",
      aggregation: "sum",
      data_type: "currency",
      source_silver_table: "silver.account_positions_daily",
      source_silver_column: "eod_balance",
      source_gold_table: "gold.fact_deposit_positions",
      source_gold_column: "balance_amount",
      metric_type: "operational",
      definition: `Total end-of-day balances for ${product} accounts`,
      sql: `SELECT as_of_date, SUM(balance_amount) FROM gold.fact_deposit_positions WHERE product_type = '${product}' GROUP BY as_of_date;`,
      level: "L2-Product",
      productType: product,
      alcoRelevance: true,
      treasuryRelevance: true,
      regulatoryRelevance: product === "CD" ? ["LCR", "NSFR"] : []
    },
    {
      domain: "Deposits",
      subdomain: `${product} Products`,
      name: `${product} Account Count`,
      technical_name: `${product.toLowerCase()}_account_count`,
      grain: "daily",
      aggregation: "count",
      data_type: "integer",
      source_silver_table: "silver.account_master",
      source_silver_column: "account_id",
      source_gold_table: "gold.dim_deposit_account",
      source_gold_column: "account_key",
      metric_type: "operational",
      definition: `Total number of active ${product} accounts`,
      sql: `SELECT as_of_date, COUNT(*) FROM gold.dim_deposit_account WHERE product_type = '${product}' AND account_status = 'ACTIVE' GROUP BY as_of_date;`,
      level: "L2-Product",
      productType: product,
      alcoRelevance: false,
      treasuryRelevance: false,
      regulatoryRelevance: []
    },
    {
      domain: "Deposits",
      subdomain: `${product} Products`,
      name: `${product} Average Balance`,
      technical_name: `${product.toLowerCase()}_avg_balance`,
      grain: "monthly",
      aggregation: "avg",
      data_type: "currency",
      source_silver_table: "silver.account_positions_daily",
      source_silver_column: "eod_balance",
      source_gold_table: "gold.fact_deposit_positions",
      source_gold_column: "balance_amount",
      metric_type: "operational",
      definition: `Average balance per ${product} account`,
      sql: `SELECT month, AVG(balance_amount) FROM gold.fact_deposit_positions WHERE product_type = '${product}' GROUP BY DATE_TRUNC('month', as_of_date) as month;`,
      level: "L2-Product",
      productType: product,
      alcoRelevance: false,
      treasuryRelevance: false,
      regulatoryRelevance: []
    },
    {
      domain: "Deposits",
      subdomain: `${product} Products`,
      name: `${product} Growth Rate (MoM)`,
      technical_name: `${product.toLowerCase()}_growth_mom`,
      grain: "monthly",
      aggregation: "calculated",
      data_type: "percent",
      source_silver_table: "silver.account_positions_daily",
      source_silver_column: "eod_balance",
      source_gold_table: "gold.fact_deposit_positions",
      source_gold_column: "balance_amount",
      metric_type: "analytics",
      definition: `Month-over-month growth rate for ${product} balances`,
      sql: `SELECT month, ((current_balance - prior_balance) / prior_balance) * 100 as growth_mom FROM (SELECT DATE_TRUNC('month', as_of_date) as month, SUM(balance_amount) as current_balance, LAG(SUM(balance_amount)) OVER (ORDER BY DATE_TRUNC('month', as_of_date)) as prior_balance FROM gold.fact_deposit_positions WHERE product_type = '${product}' GROUP BY month);`,
      level: "L2-Product",
      productType: product,
      alcoRelevance: true,
      treasuryRelevance: false,
      regulatoryRelevance: []
    },
    {
      domain: "Deposits",
      subdomain: `${product} Products`,
      name: `${product} Cost of Funds`,
      technical_name: `${product.toLowerCase()}_cof`,
      grain: "monthly",
      aggregation: "weighted_avg",
      data_type: "percent",
      source_silver_table: "silver.interest_accruals",
      source_silver_column: "accrued_interest",
      source_gold_table: "gold.fact_deposit_interest",
      source_gold_column: "interest_expense",
      metric_type: "operational",
      definition: `Interest expense as % of average balance for ${product} (annualized)`,
      sql: `SELECT month, (SUM(interest_expense) * 12 / AVG(balance_amount)) * 100 as cof FROM gold.fact_deposit_interest WHERE product_type = '${product}' GROUP BY DATE_TRUNC('month', as_of_date) as month;`,
      level: "L2-Product",
      productType: product,
      alcoRelevance: true,
      treasuryRelevance: true,
      regulatoryRelevance: []
    }
  );
});

// CD-specific maturity metrics
const cdMaturityMetrics: Omit<DepositsMetric, "id">[] = [
  {
    domain: "Deposits",
    subdomain: "CD Products",
    name: "CD Maturing in 30 Days",
    technical_name: "cd_maturing_30d",
    grain: "daily",
    aggregation: "sum",
    data_type: "currency",
    source_silver_table: "silver.cd_master",
    source_silver_column: "principal_amount",
    source_gold_table: "gold.fact_cd_maturity",
    source_gold_column: "maturity_amount",
    metric_type: "operational",
    definition: "Total CD principal maturing within next 30 days",
    sql: "SELECT as_of_date, SUM(principal_amount) FROM gold.fact_cd_maturity WHERE maturity_date BETWEEN as_of_date AND as_of_date + INTERVAL '30 days' GROUP BY as_of_date;",
    level: "L2-Product",
    productType: "CD",
    alcoRelevance: true,
    treasuryRelevance: true,
    regulatoryRelevance: ["LCR"]
  },
  {
    domain: "Deposits",
    subdomain: "CD Products",
    name: "CD Maturing in 90 Days",
    technical_name: "cd_maturing_90d",
    grain: "daily",
    aggregation: "sum",
    data_type: "currency",
    source_silver_table: "silver.cd_master",
    source_silver_column: "principal_amount",
    source_gold_table: "gold.fact_cd_maturity",
    source_gold_column: "maturity_amount",
    metric_type: "operational",
    definition: "Total CD principal maturing within next 90 days",
    sql: "SELECT as_of_date, SUM(principal_amount) FROM gold.fact_cd_maturity WHERE maturity_date BETWEEN as_of_date AND as_of_date + INTERVAL '90 days' GROUP BY as_of_date;",
    level: "L2-Product",
    productType: "CD",
    alcoRelevance: true,
    treasuryRelevance: true,
    regulatoryRelevance: ["LCR", "NSFR"]
  },
  {
    domain: "Deposits",
    subdomain: "CD Products",
    name: "CD Renewal Rate",
    technical_name: "cd_renewal_rate",
    grain: "monthly",
    aggregation: "calculated",
    data_type: "percent",
    source_silver_table: "silver.cd_maturities",
    source_silver_column: "renewed_flag",
    source_gold_table: "gold.fact_cd_renewals",
    source_gold_column: "renewal_indicator",
    metric_type: "analytics",
    definition: "Percentage of maturing CDs that are renewed (rollover rate)",
    sql: "SELECT month, (SUM(CASE WHEN renewed_flag THEN principal_amount ELSE 0 END) / SUM(principal_amount)) * 100 as renewal_rate FROM gold.fact_cd_renewals GROUP BY DATE_TRUNC('month', maturity_date) as month;",
    level: "L2-Product",
    productType: "CD",
    alcoRelevance: true,
    treasuryRelevance: true,
    regulatoryRelevance: []
  },
  {
    domain: "Deposits",
    subdomain: "CD Products",
    name: "CD Early Withdrawal Rate",
    technical_name: "cd_early_withdrawal_rate",
    grain: "monthly",
    aggregation: "calculated",
    data_type: "percent",
    source_silver_table: "silver.cd_transactions",
    source_silver_column: "transaction_type",
    source_gold_table: "gold.fact_cd_transactions",
    source_gold_column: "early_withdrawal_flag",
    metric_type: "analytics",
    definition: "Percentage of CDs withdrawn before maturity",
    sql: "SELECT month, (COUNT(CASE WHEN early_withdrawal_flag THEN 1 END) / COUNT(*)) * 100 as early_withdrawal_pct FROM gold.fact_cd_transactions WHERE transaction_type = 'WITHDRAWAL' GROUP BY DATE_TRUNC('month', transaction_date) as month;",
    level: "L2-Product",
    productType: "CD",
    alcoRelevance: true,
    treasuryRelevance: false,
    regulatoryRelevance: []
  },
];

productLevelMetrics.push(...cdMaturityMetrics);

// DDA-specific transaction metrics
const ddaTransactionMetrics: Omit<DepositsMetric, "id">[] = [
  {
    domain: "Deposits",
    subdomain: "DDA Products",
    name: "DDA Transaction Volume",
    technical_name: "dda_transaction_volume",
    grain: "daily",
    aggregation: "count",
    data_type: "integer",
    source_silver_table: "silver.account_transactions",
    source_silver_column: "transaction_id",
    source_gold_table: "gold.fact_deposit_transactions",
    source_gold_column: "transaction_key",
    metric_type: "operational",
    definition: "Total number of transactions on DDA accounts",
    sql: "SELECT transaction_date, COUNT(*) FROM gold.fact_deposit_transactions WHERE product_type = 'DDA' GROUP BY transaction_date;",
    level: "L2-Product",
    productType: "DDA",
    alcoRelevance: false,
    treasuryRelevance: false,
    regulatoryRelevance: []
  },
  {
    domain: "Deposits",
    subdomain: "DDA Products",
    name: "DDA Transaction Amount",
    technical_name: "dda_transaction_amount",
    grain: "daily",
    aggregation: "sum",
    data_type: "currency",
    source_silver_table: "silver.account_transactions",
    source_silver_column: "transaction_amount",
    source_gold_table: "gold.fact_deposit_transactions",
    source_gold_column: "amount",
    metric_type: "operational",
    definition: "Total transaction amount (debits + credits) for DDA accounts",
    sql: "SELECT transaction_date, SUM(ABS(amount)) FROM gold.fact_deposit_transactions WHERE product_type = 'DDA' GROUP BY transaction_date;",
    level: "L2-Product",
    productType: "DDA",
    alcoRelevance: false,
    treasuryRelevance: false,
    regulatoryRelevance: []
  },
  {
    domain: "Deposits",
    subdomain: "DDA Products",
    name: "DDA Overdraft Rate",
    technical_name: "dda_overdraft_rate",
    grain: "monthly",
    aggregation: "calculated",
    data_type: "percent",
    source_silver_table: "silver.account_positions_daily",
    source_silver_column: "eod_balance",
    source_gold_table: "gold.fact_deposit_positions",
    source_gold_column: "balance_amount",
    metric_type: "analytics",
    definition: "Percentage of DDA accounts with negative balances (overdrafts)",
    sql: "SELECT month, (COUNT(CASE WHEN balance_amount < 0 THEN 1 END) / COUNT(*)) * 100 as overdraft_rate FROM gold.fact_deposit_positions WHERE product_type = 'DDA' GROUP BY DATE_TRUNC('month', as_of_date) as month;",
    level: "L2-Product",
    productType: "DDA",
    alcoRelevance: false,
    treasuryRelevance: false,
    regulatoryRelevance: ["Reg E", "Overdraft Rules"]
  },
  {
    domain: "Deposits",
    subdomain: "DDA Products",
    name: "DDA Dormancy Rate",
    technical_name: "dda_dormancy_rate",
    grain: "monthly",
    aggregation: "calculated",
    data_type: "percent",
    source_silver_table: "silver.account_transactions",
    source_silver_column: "transaction_date",
    source_gold_table: "gold.fact_account_activity",
    source_gold_column: "last_transaction_date",
    metric_type: "analytics",
    definition: "Percentage of DDA accounts with no transactions in 90+ days",
    sql: "SELECT month, (COUNT(CASE WHEN DATEDIFF(month, last_transaction_date) > 90 THEN 1 END) / COUNT(*)) * 100 as dormancy_rate FROM gold.fact_account_activity WHERE product_type = 'DDA' GROUP BY month;",
    level: "L2-Product",
    productType: "DDA",
    alcoRelevance: false,
    treasuryRelevance: false,
    regulatoryRelevance: ["Escheatment"]
  },
];

productLevelMetrics.push(...ddaTransactionMetrics);

// Continue in next part...
const remainingProductMetrics: Omit<DepositsMetric, "id">[] = [
  {
    domain: "Deposits",
    subdomain: "Savings Products",
    name: "Savings Withdrawal Rate",
    technical_name: "savings_withdrawal_rate",
    grain: "monthly",
    aggregation: "calculated",
    data_type: "decimal",
    source_silver_table: "silver.account_transactions",
    source_silver_column: "transaction_amount",
    source_gold_table: "gold.fact_deposit_transactions",
    source_gold_column: "amount",
    metric_type: "analytics",
    definition: "Average number of withdrawals per savings account per month",
    sql: "SELECT month, COUNT(CASE WHEN transaction_type = 'WITHDRAWAL' THEN 1 END) / COUNT(DISTINCT account_id) as withdrawal_rate FROM gold.fact_deposit_transactions WHERE product_type = 'Savings' GROUP BY DATE_TRUNC('month', transaction_date) as month;",
    level: "L2-Product",
    productType: "Savings",
    alcoRelevance: false,
    treasuryRelevance: false,
    regulatoryRelevance: ["Reg D"]
  },
  {
    domain: "Deposits",
    subdomain: "MMA Products",
    name: "MMA Balance Tiers Distribution",
    technical_name: "mma_tier_distribution",
    grain: "monthly",
    aggregation: "calculated",
    data_type: "percent",
    source_silver_table: "silver.account_positions_daily",
    source_silver_column: "eod_balance",
    source_gold_table: "gold.fact_deposit_positions",
    source_gold_column: "balance_amount",
    metric_type: "analytics",
    definition: "Distribution of MMA balances across rate tiers",
    sql: "SELECT month, rate_tier, (SUM(balance_amount) / SUM(SUM(balance_amount)) OVER (PARTITION BY month)) * 100 as tier_pct FROM gold.fact_deposit_positions WHERE product_type = 'MMA' GROUP BY DATE_TRUNC('month', as_of_date) as month, rate_tier;",
    level: "L2-Product",
    productType: "MMA",
    alcoRelevance: true,
    treasuryRelevance: false,
    regulatoryRelevance: []
  },
];

productLevelMetrics.push(...remainingProductMetrics);

// ============================================================================
// LEVEL 3: SEGMENT-LEVEL METRICS (~100 metrics)
// ============================================================================

const segmentMetrics: Omit<DepositsMetric, "id">[] = [];

const customerSegments = ["Retail", "Small Business", "Commercial", "Private Banking", "Institutional"];

customerSegments.forEach(segment => {
  segmentMetrics.push(
    {
      domain: "Deposits",
      subdomain: "Customer Segmentation",
      name: `${segment} Deposit Balances`,
      technical_name: `${segment.toLowerCase().replace(/ /g, "_")}_balances`,
      grain: "monthly",
      aggregation: "sum",
      data_type: "currency",
      source_silver_table: "silver.customer_balances",
      source_silver_column: "balance_amount",
      source_gold_table: "gold.fact_deposit_positions",
      source_gold_column: "balance_amount",
      metric_type: "operational",
      definition: `Total deposit balances for ${segment} customer segment`,
      sql: `SELECT month, SUM(balance_amount) FROM gold.fact_deposit_positions dp JOIN gold.dim_customer c ON dp.customer_key = c.customer_key WHERE c.customer_segment = '${segment}' GROUP BY DATE_TRUNC('month', as_of_date) as month;`,
      level: "L3-Segment",
      productType: "All",
      alcoRelevance: true,
      treasuryRelevance: false,
      regulatoryRelevance: []
    },
    {
      domain: "Deposits",
      subdomain: "Customer Segmentation",
      name: `${segment} Customer Count`,
      technical_name: `${segment.toLowerCase().replace(/ /g, "_")}_customer_count`,
      grain: "monthly",
      aggregation: "count",
      data_type: "integer",
      source_silver_table: "silver.customer_master",
      source_silver_column: "customer_id",
      source_gold_table: "gold.dim_customer",
      source_gold_column: "customer_key",
      metric_type: "operational",
      definition: `Number of active customers in ${segment} segment with deposit accounts`,
      sql: `SELECT month, COUNT(DISTINCT customer_key) FROM gold.dim_customer WHERE customer_segment = '${segment}' AND has_deposit_account = TRUE GROUP BY month;`,
      level: "L3-Segment",
      productType: "All",
      alcoRelevance: false,
      treasuryRelevance: false,
      regulatoryRelevance: []
    },
    {
      domain: "Deposits",
      subdomain: "Customer Segmentation",
      name: `${segment} Average Balance per Customer`,
      technical_name: `${segment.toLowerCase().replace(/ /g, "_")}_avg_balance_per_customer`,
      grain: "monthly",
      aggregation: "avg",
      data_type: "currency",
      source_silver_table: "silver.customer_balances",
      source_silver_column: "total_balance",
      source_gold_table: "gold.fact_customer_balances",
      source_gold_column: "total_deposit_balance",
      metric_type: "operational",
      definition: `Average total deposit balance per customer in ${segment} segment`,
      sql: `SELECT month, AVG(total_deposit_balance) FROM gold.fact_customer_balances WHERE customer_segment = '${segment}' GROUP BY month;`,
      level: "L3-Segment",
      productType: "All",
      alcoRelevance: false,
      treasuryRelevance: false,
      regulatoryRelevance: []
    }
  );
});

// Geographic metrics
const regions = ["Northeast", "Southeast", "Midwest", "Southwest", "West"];

regions.forEach(region => {
  segmentMetrics.push(
    {
      domain: "Deposits",
      subdomain: "Geographic Analysis",
      name: `${region} Region Deposits`,
      technical_name: `${region.toLowerCase()}_deposits`,
      grain: "monthly",
      aggregation: "sum",
      data_type: "currency",
      source_silver_table: "silver.branch_balances",
      source_silver_column: "balance_amount",
      source_gold_table: "gold.fact_deposit_positions",
      source_gold_column: "balance_amount",
      metric_type: "operational",
      definition: `Total deposit balances in ${region} region`,
      sql: `SELECT month, SUM(dp.balance_amount) FROM gold.fact_deposit_positions dp JOIN gold.dim_branch b ON dp.branch_key = b.branch_key WHERE b.region = '${region}' GROUP BY DATE_TRUNC('month', as_of_date) as month;`,
      level: "L3-Segment",
      productType: "All",
      alcoRelevance: false,
      treasuryRelevance: false,
      regulatoryRelevance: []
    }
  );
});

// Channel metrics
const channels = ["Branch", "Online", "Mobile", "ATM", "Call Center"];

channels.forEach(channel => {
  segmentMetrics.push(
    {
      domain: "Deposits",
      subdomain: "Channel Analytics",
      name: `${channel} Account Openings`,
      technical_name: `${channel.toLowerCase().replace(/ /g, "_")}_openings`,
      grain: "monthly",
      aggregation: "count",
      data_type: "integer",
      source_silver_table: "silver.account_events",
      source_silver_column: "account_id",
      source_gold_table: "gold.fact_account_events",
      source_gold_column: "account_key",
      metric_type: "operational",
      definition: `Number of deposit accounts opened through ${channel} channel`,
      sql: `SELECT month, COUNT(*) FROM gold.fact_account_events WHERE event_type = 'OPENED' AND channel = '${channel}' GROUP BY DATE_TRUNC('month', event_date) as month;`,
      level: "L3-Segment",
      productType: "All",
      alcoRelevance: false,
      treasuryRelevance: false,
      regulatoryRelevance: []
    }
  );
});

// ============================================================================
// LEVEL 4: GRANULAR OPERATIONAL METRICS (~50 metrics)
// ============================================================================

const granularMetrics: Omit<DepositsMetric, "id">[] = [
  {
    domain: "Deposits",
    subdomain: "Daily Operations",
    name: "Daily Deposit Inflows",
    technical_name: "daily_deposit_inflows",
    grain: "daily",
    aggregation: "sum",
    data_type: "currency",
    source_silver_table: "silver.account_transactions",
    source_silver_column: "transaction_amount",
    source_gold_table: "gold.fact_deposit_transactions",
    source_gold_column: "amount",
    metric_type: "operational",
    definition: "Total deposit (credit) transactions for the day",
    sql: "SELECT transaction_date, SUM(amount) FROM gold.fact_deposit_transactions WHERE transaction_type = 'CREDIT' GROUP BY transaction_date;",
    level: "L4-Granular",
    productType: "All",
    alcoRelevance: true,
    treasuryRelevance: true,
    regulatoryRelevance: []
  },
  {
    domain: "Deposits",
    subdomain: "Daily Operations",
    name: "Daily Deposit Outflows",
    technical_name: "daily_deposit_outflows",
    grain: "daily",
    aggregation: "sum",
    data_type: "currency",
    source_silver_table: "silver.account_transactions",
    source_silver_column: "transaction_amount",
    source_gold_table: "gold.fact_deposit_transactions",
    source_gold_column: "amount",
    metric_type: "operational",
    definition: "Total withdrawal (debit) transactions for the day",
    sql: "SELECT transaction_date, SUM(ABS(amount)) FROM gold.fact_deposit_transactions WHERE transaction_type = 'DEBIT' GROUP BY transaction_date;",
    level: "L4-Granular",
    productType: "All",
    alcoRelevance: true,
    treasuryRelevance: true,
    regulatoryRelevance: []
  },
  {
    domain: "Deposits",
    subdomain: "Daily Operations",
    name: "Net Daily Deposit Flow",
    technical_name: "net_daily_flow",
    grain: "daily",
    aggregation: "calculated",
    data_type: "currency",
    source_silver_table: "silver.account_transactions",
    source_silver_column: "transaction_amount",
    source_gold_table: "gold.fact_deposit_transactions",
    source_gold_column: "amount",
    metric_type: "operational",
    definition: "Net deposit flow (inflows minus outflows) for the day",
    sql: "SELECT transaction_date, SUM(CASE WHEN transaction_type = 'CREDIT' THEN amount ELSE -ABS(amount) END) as net_flow FROM gold.fact_deposit_transactions GROUP BY transaction_date;",
    level: "L4-Granular",
    productType: "All",
    alcoRelevance: true,
    treasuryRelevance: true,
    regulatoryRelevance: []
  },
  {
    domain: "Deposits",
    subdomain: "Fee Income",
    name: "Monthly Maintenance Fees",
    technical_name: "monthly_maintenance_fees",
    grain: "monthly",
    aggregation: "sum",
    data_type: "currency",
    source_silver_table: "silver.fee_transactions",
    source_silver_column: "fee_amount",
    source_gold_table: "gold.fact_deposit_fees",
    source_gold_column: "fee_revenue",
    metric_type: "operational",
    definition: "Total monthly account maintenance fee revenue",
    sql: "SELECT month, SUM(fee_revenue) FROM gold.fact_deposit_fees WHERE fee_type = 'MONTHLY_MAINTENANCE' GROUP BY DATE_TRUNC('month', fee_date) as month;",
    level: "L4-Granular",
    productType: "All",
    alcoRelevance: false,
    treasuryRelevance: false,
    regulatoryRelevance: []
  },
  {
    domain: "Deposits",
    subdomain: "Fee Income",
    name: "Overdraft Fee Revenue",
    technical_name: "overdraft_fee_revenue",
    grain: "monthly",
    aggregation: "sum",
    data_type: "currency",
    source_silver_table: "silver.fee_transactions",
    source_silver_column: "fee_amount",
    source_gold_table: "gold.fact_deposit_fees",
    source_gold_column: "fee_revenue",
    metric_type: "operational",
    definition: "Total overdraft and NSF fee revenue",
    sql: "SELECT month, SUM(fee_revenue) FROM gold.fact_deposit_fees WHERE fee_type IN ('OVERDRAFT', 'NSF') GROUP BY DATE_TRUNC('month', fee_date) as month;",
    level: "L4-Granular",
    productType: "DDA",
    alcoRelevance: false,
    treasuryRelevance: false,
    regulatoryRelevance: ["Reg E", "Consumer Protection"]
  },
  {
    domain: "Deposits",
    subdomain: "Fee Income",
    name: "Wire Transfer Fee Revenue",
    technical_name: "wire_transfer_fee_revenue",
    grain: "monthly",
    aggregation: "sum",
    data_type: "currency",
    source_silver_table: "silver.fee_transactions",
    source_silver_column: "fee_amount",
    source_gold_table: "gold.fact_deposit_fees",
    source_gold_column: "fee_revenue",
    metric_type: "operational",
    definition: "Total wire transfer fee revenue from deposit accounts",
    sql: "SELECT month, SUM(fee_revenue) FROM gold.fact_deposit_fees WHERE fee_type = 'WIRE_TRANSFER' GROUP BY DATE_TRUNC('month', fee_date) as month;",
    level: "L4-Granular",
    productType: "All",
    alcoRelevance: false,
    treasuryRelevance: false,
    regulatoryRelevance: []
  },
  {
    domain: "Deposits",
    subdomain: "Account Lifecycle",
    name: "Account Opening Funnel - Applications",
    technical_name: "opening_funnel_applications",
    grain: "weekly",
    aggregation: "count",
    data_type: "integer",
    source_silver_table: "silver.account_applications",
    source_silver_column: "application_id",
    source_gold_table: "gold.fact_account_funnel",
    source_gold_column: "application_key",
    metric_type: "operational",
    definition: "Number of deposit account applications submitted",
    sql: "SELECT week, COUNT(*) FROM gold.fact_account_funnel WHERE funnel_stage = 'APPLICATION' GROUP BY DATE_TRUNC('week', application_date) as week;",
    level: "L4-Granular",
    productType: "All",
    alcoRelevance: false,
    treasuryRelevance: false,
    regulatoryRelevance: []
  },
  {
    domain: "Deposits",
    subdomain: "Account Lifecycle",
    name: "Account Opening Funnel - Approvals",
    technical_name: "opening_funnel_approvals",
    grain: "weekly",
    aggregation: "count",
    data_type: "integer",
    source_silver_table: "silver.account_applications",
    source_silver_column: "application_id",
    source_gold_table: "gold.fact_account_funnel",
    source_gold_column: "application_key",
    metric_type: "operational",
    definition: "Number of deposit account applications approved",
    sql: "SELECT week, COUNT(*) FROM gold.fact_account_funnel WHERE funnel_stage = 'APPROVED' GROUP BY DATE_TRUNC('week', approval_date) as week;",
    level: "L4-Granular",
    productType: "All",
    alcoRelevance: false,
    treasuryRelevance: false,
    regulatoryRelevance: []
  },
  {
    domain: "Deposits",
    subdomain: "Account Lifecycle",
    name: "Account Opening Funnel - Funded",
    technical_name: "opening_funnel_funded",
    grain: "weekly",
    aggregation: "count",
    data_type: "integer",
    source_silver_table: "silver.account_applications",
    source_silver_column: "application_id",
    source_gold_table: "gold.fact_account_funnel",
    source_gold_column: "application_key",
    metric_type: "operational",
    definition: "Number of new accounts that received initial funding",
    sql: "SELECT week, COUNT(*) FROM gold.fact_account_funnel WHERE funnel_stage = 'FUNDED' GROUP BY DATE_TRUNC('week', funding_date) as week;",
    level: "L4-Granular",
    productType: "All",
    alcoRelevance: false,
    treasuryRelevance: false,
    regulatoryRelevance: []
  },
  {
    domain: "Deposits",
    subdomain: "Account Lifecycle",
    name: "Conversion Rate - Application to Approval",
    technical_name: "conversion_app_to_approval",
    grain: "monthly",
    aggregation: "calculated",
    data_type: "percent",
    source_silver_table: "silver.account_applications",
    source_silver_column: "application_status",
    source_gold_table: "gold.fact_account_funnel",
    source_gold_column: "funnel_stage",
    metric_type: "analytics",
    definition: "Percentage of applications that get approved",
    sql: "SELECT month, (COUNT(CASE WHEN funnel_stage = 'APPROVED' THEN 1 END) / COUNT(*)) * 100 as conversion_rate FROM gold.fact_account_funnel WHERE funnel_stage IN ('APPLICATION', 'APPROVED') GROUP BY DATE_TRUNC('month', application_date) as month;",
    level: "L4-Granular",
    productType: "All",
    alcoRelevance: false,
    treasuryRelevance: false,
    regulatoryRelevance: []
  },
];

// Add more granular metrics for interest calculations
const interestMetrics: Omit<DepositsMetric, "id">[] = [
  {
    domain: "Deposits",
    subdomain: "Interest Management",
    name: "Daily Interest Accrual",
    technical_name: "daily_interest_accrual",
    grain: "daily",
    aggregation: "sum",
    data_type: "currency",
    source_silver_table: "silver.interest_accruals",
    source_silver_column: "accrued_amount",
    source_gold_table: "gold.fact_deposit_interest",
    source_gold_column: "daily_accrual",
    metric_type: "operational",
    definition: "Total interest accrued on deposit accounts for the day",
    sql: "SELECT accrual_date, SUM(daily_accrual) FROM gold.fact_deposit_interest GROUP BY accrual_date;",
    level: "L4-Granular",
    productType: "All",
    alcoRelevance: true,
    treasuryRelevance: true,
    regulatoryRelevance: []
  },
  {
    domain: "Deposits",
    subdomain: "Interest Management",
    name: "Monthly Interest Paid",
    technical_name: "monthly_interest_paid",
    grain: "monthly",
    aggregation: "sum",
    data_type: "currency",
    source_silver_table: "silver.interest_payments",
    source_silver_column: "payment_amount",
    source_gold_table: "gold.fact_deposit_interest",
    source_gold_column: "interest_paid",
    metric_type: "operational",
    definition: "Total interest paid to deposit accounts during the month",
    sql: "SELECT month, SUM(interest_paid) FROM gold.fact_deposit_interest GROUP BY DATE_TRUNC('month', payment_date) as month;",
    level: "L4-Granular",
    productType: "All",
    alcoRelevance: true,
    treasuryRelevance: true,
    regulatoryRelevance: []
  },
];

granularMetrics.push(...interestMetrics);

// ============================================================================
// COMBINE ALL METRICS
// ============================================================================

const allDepositsMetrics: Omit<DepositsMetric, "id">[] = [
  ...portfolioMetrics,
  ...productLevelMetrics,
  ...segmentMetrics,
  ...granularMetrics,
];

// Add IDs and export
export const depositsMetricsCatalog: DepositsMetric[] = allDepositsMetrics.map((metric, idx) => ({
  ...metric,
  id: `deposits_${metric.technical_name}_${idx}`,
}));

// Summary statistics
export const depositsStats = {
  totalMetrics: depositsMetricsCatalog.length,
  byLevel: {
    L1: depositsMetricsCatalog.filter(m => m.level === "L1-Portfolio").length,
    L2: depositsMetricsCatalog.filter(m => m.level === "L2-Product").length,
    L3: depositsMetricsCatalog.filter(m => m.level === "L3-Segment").length,
    L4: depositsMetricsCatalog.filter(m => m.level === "L4-Granular").length,
  },
  byProduct: {
    All: depositsMetricsCatalog.filter(m => m.productType === "All").length,
    DDA: depositsMetricsCatalog.filter(m => m.productType === "DDA").length,
    Savings: depositsMetricsCatalog.filter(m => m.productType === "Savings").length,
    MMA: depositsMetricsCatalog.filter(m => m.productType === "MMA").length,
    CD: depositsMetricsCatalog.filter(m => m.productType === "CD").length,
  },
  byType: {
    operational: depositsMetricsCatalog.filter(m => m.metric_type === "operational").length,
    analytics: depositsMetricsCatalog.filter(m => m.metric_type === "analytics").length,
    insight: depositsMetricsCatalog.filter(m => m.metric_type === "insight").length,
    model_driven: depositsMetricsCatalog.filter(m => m.metric_type === "model_driven").length,
  },
  alcoRelevant: depositsMetricsCatalog.filter(m => m.alcoRelevance).length,
  treasuryRelevant: depositsMetricsCatalog.filter(m => m.treasuryRelevance).length,
};
